= Views and Navigation with Vaadin Spring


== Spring Views
The views themselves should be annotated with `@SpringView` to be found by `SpringViewProvider`.

Let's start with a default view:

[source, java]
.DefaultView.java
----
@SpringView(name = DefaultView.VIEW_NAME)
public class DefaultView extends VerticalLayout implements View {
    public static final String VIEW_NAME = "";

    @PostConstruct
    void init() {
        addComponent(new Label("This is the default view"));
    }

    @Override
    public void enter(ViewChangeEvent event) {
        // This view is constructed in the init() method()
    }
}
----

This view is registered automatically based on the `@SpringView` annotation. As it has an empty string as its view name,
it will be shown when navigating to http://localhost:8080/ .

To see how navigation between views works, we can create another view mapped to a different view name. Note the use of a
constant for the view name, which is a good practice and allows you to easily refer to the views.

[source, java]
.ViewScopedView.java
----
@SpringView(name = ViewScopedView.VIEW_NAME)
public class ViewScopedView extends VerticalLayout implements View {
    public static final String VIEW_NAME = "view";

    @PostConstruct
    void init() {
        setMargin(true);
        setSpacing(true);
        addComponent(new Label("This is a view scoped view"));
    }

    @Override
    public void enter(ViewChangeEvent event) {
        // This view is constructed in the init() method()
    }
}
----
Also this view is automatically registered as it has the `@SpringView` annotation, so we would be able to open it by
opening http://localhost:8080#!view . However, we'll want to make it easy to enter the view, so let's add a navigation button for it in the UI:

[source, java]
.MyUI.java
----
@Theme("valo")
@SpringUI
@ViewContainer

public class MyUI extends UI implements ViewDisplay {

    private Panel viewContainer;

    @Override
    protected void init(VaadinRequest request) {
        final VerticalLayout root = new VerticalLayout();
        root.setSizeFull();
        root.setMargin(true);
        root.setSpacing(true);
        setContent(root);

        final CssLayout navigationBar = new CssLayout();
        navigationBar.addStyleName(ValoTheme.LAYOUT_COMPONENT_GROUP);
        navigationBar.addComponent(createNavigationButton("View Scoped View",
                ViewScopedView.VIEW_NAME));
        root.addComponent(navigationBar);

        viewContainer = new Panel();
        viewContainer.setSizeFull();
        root.addComponent(viewContainer);
        root.setExpandRatio(viewContainer, 1.0f);

    }

    private Button createNavigationButton(String caption, final String viewName) {
        Button button = new Button(caption);
        button.addStyleName(ValoTheme.BUTTON_SMALL);
        // If you didn't choose Java 8 when creating the project, convert this
        // to an anonymous listener class
        button.addClickListener(event -> getUI().getNavigator().navigateTo(viewName));
        return button;
    }

    @Override
    public void showView(View view) {
        viewContainer.setContent((Component) view);
    }
}
----
Now fire up the application class and go to http://localhost:8080/ to see this in action.

== Views and Scopes
Let's add one more view, this time a UI scoped view, and inject a `Greeter` into it:

[source, java]
.UIScopedView.java
----
// Pay attention to the order of annotations
@UIScope
@SpringView(name = UIScopedView.VIEW_NAME)
public class UIScopedView extends VerticalLayout implements View {
    public static final String VIEW_NAME = "ui";

    @Autowired
    private Greeter greeter;

    @PostConstruct
    void init() {
        setMargin(true);
        setSpacing(true);
        addComponent(new Label("This is a UI scoped view. Greeter says: " + greeter.sayHello()));
    }

    @Override
    public void enter(ViewChangeEvent event) {
        // This view is constructed in the init() method()
    }
}
----
After this, what remains is to add a navigation button for it in the UI:

[source, java]
.MyUI.java
----
        ...
        navigationBar.addComponent(createNavigationButton("UI Scoped View",
                UIScopedView.VIEW_NAME));
        navigationBar.addComponent(createNavigationButton("View Scoped View",
                ViewScopedView.VIEW_NAME));
        ...
----
That's it.

Note that now when navigating between the views, you always get the same instance of the UI scoped view (within the same UI) but a new instance of the view scoped view every time when navigating to it. To verify that this is the case, we can inject some more beans to our views:

[source, java]
.ViewGreeter.java
----
@SpringComponent
@ViewScope
public class ViewGreeter {
    public String sayHello() {
        return "Hello from a view scoped bean " + toString();
    }
}
----
Note the annotation `@ViewScope`, which makes the lifecycle and injection of instances of this bean view specific.

[source, java]
.ViewScopedView.java
----
@SpringView(name = ViewScopedView.VIEW_NAME)
public class ViewScopedView extends VerticalLayout implements View {
    public static final String VIEW_NAME = "view";

    // A new instance will be created for every view instance created
    @Autowired
    private ViewGreeter viewGreeter;

    // The same instance will be used by all views of the UI
    @Autowired
    private Greeter uiGreeter;

    @PostConstruct
    void init() {
        setMargin(true);
        setSpacing(true);
        addComponent(new Label("This is a view scoped view"));
        addComponent(new Label(uiGreeter.sayHello()));
        addComponent(new Label(viewGreeter.sayHello()));
    }

    @Override
    public void enter(ViewChangeEvent event) {
        // This view is constructed in the init() method()
    }
}
----
Now when switching views, the UI scoped greeter instance and the UI scoped view will stay the same, whereas the view scoped greeter (and the view itself) will be regenerated every time when entering the view.

== Automatic view name generation

Using explicit view names is strongly recommended, but it is possible to omit the view name, in which case a name is automatically generated based on the class name. If an explicit name is not provided the class name of the UI will be used to construct a pathname by the following convention: any trailing "View" will be truncated and camelcase will be converted to hyphenated lowercase. Some examples of the convention:

HelloWorldView → hello-world

ExampleView → example

VisualEditor → visual-editor

== Access Control and Error Views

When looking for accessible views, `SpringViewProvider` first looks for views that can be used with the current UI.
It is possible to restrict a view to specific UI classes using an annotation parameter like `@SpringView(VIEW_NAME, ui={ MyUIClass.class })`.

After selecting such candidate views, access to that view is checked in two phases with all the view access delegates
that have been registered. Thus, any Spring bean implementing `ViewAccessControl` is first asked if access is granted to
a view with the given bean name. If no access delegate blocks access to the view based on the bean name, a second check
is made with a specific view instance by calling all beans implementing `ViewInstanceAccessControl`. If access to the
view is denied by any access control bean, the view provider will default act as if the view didn't exist. However, an
"access denied" view can be registered with `SpringViewProvider.setAccessDeniedViewClass()` if a specific "access denied" view is desired.

You can also define a generic error view when the user tries to navigate to a view that does not exist. This is
configured simply by calling `navigator.setErrorView(new ErrorView())` in your UI `init()` method or wherever the navigator is set up.

Note that Spring Security is not covered by this tutorial. The unofficial add-on vaadin4spring that build on top of
the official add-on also provides easy integration of Spring Security as well as a "sidebar" module that makes
constructing a UI for navigation in a Vaadin Spring application easier.
